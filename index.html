<!DOCTYPE html>


<html lang="zh-CN,en,default">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="share everything I want to share" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Yangyang</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon2.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/yangocean-sudo"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/wall_paper_code_sleep.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Yangyang</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle">Think. Learn. Create</span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Try to update hard.</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Leetcode1113"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/13/Leetcode1113/"
    >LLeetcode Study Day 47</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/13/Leetcode1113/" class="article-date">
  <time datetime="2023-11-13T19:48:49.000Z" itemprop="datePublished">2023-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h1><p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>
<p>Implement the Trie class:</p>
<p>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; return True</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; return True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; word.length, prefix.length &lt;&#x3D; 2000</span><br><span class="line">word and prefix consist only of lowercase English letters.</span><br><span class="line">At most 3 * 104 calls in total will be made to insert, search, and startsWith.</span><br></pre></td></tr></table></figure>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>My solution is easy to understand but cost a lot of time to process.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">         wordSet.insert(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordSet.find(word) != wordSet.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prefix.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word: wordSet)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prefix[i] != word[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(prefix[i] == word[i] &amp;&amp; i == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span> &lt;<span class="built_in">string</span>&gt; wordSet;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="Prefix-Tree"><a href="#Prefix-Tree" class="headerlink" title="Prefix Tree"></a>Prefix Tree</h2><p>I got the idea of using prefix tree from this <a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3307049/day-76-easiest-beginner-friendly-sol/?envType=study-plan-v2&envId=top-interview-150">post</a> in Leetcode.</p>
<p>I am going to explain his code with comment:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// create an array with 26 TrieNode pointers</span></span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWordCompleted;</span><br><span class="line"></span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="keyword">sizeof</span>(children));</span><br><span class="line">        isWordCompleted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* newRoot = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">            <span class="comment">// get the index of the alphabet</span></span><br><span class="line">            <span class="keyword">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// if the pointer is NULL, create a new TrieNode</span></span><br><span class="line">            <span class="keyword">if</span> (newRoot -&gt; children[alphabetIndex] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                newRoot -&gt; children[alphabetIndex] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// move the pointer to the next TrieNode</span></span><br><span class="line">            newRoot = newRoot -&gt; children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mark the word as completed</span></span><br><span class="line">        newRoot -&gt; isWordCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode* newRoot = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">            <span class="keyword">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// if the pointer is NULL, means the character is not in the tree</span></span><br><span class="line">            <span class="keyword">if</span> (newRoot -&gt; children[alphabetIndex] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            newRoot = newRoot -&gt; children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if the word is completed, return true</span></span><br><span class="line">        <span class="keyword">if</span> (newRoot -&gt; isWordCompleted == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* newRoot = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix) &#123;</span><br><span class="line">            <span class="keyword">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (newRoot -&gt; children[alphabetIndex] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            newRoot = newRoot -&gt; children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Design-Add-and-Search-Words-Data-Structure"><a href="#Design-Add-and-Search-Words-Data-Structure" class="headerlink" title="Design Add and Search Words Data Structure"></a>Design Add and Search Words Data Structure</h1><p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>
<p>Implement the WordDictionary class:</p>
<p>WordDictionary() Initializes the object.<br>void addWord(word) Adds word to the data structure, it can be matched later.<br>bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots ‘.’ where dots can be matched with any letter.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span><br><span class="line">[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,false,true,true,true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">WordDictionary wordDictionary &#x3D; new WordDictionary();</span><br><span class="line">wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">wordDictionary.search(&quot;pad&quot;); &#x2F;&#x2F; return False</span><br><span class="line">wordDictionary.search(&quot;bad&quot;); &#x2F;&#x2F; return True</span><br><span class="line">wordDictionary.search(&quot;.ad&quot;); &#x2F;&#x2F; return True</span><br><span class="line">wordDictionary.search(&quot;b..&quot;); &#x2F;&#x2F; return True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; word.length &lt;&#x3D; 25</span><br><span class="line">word in addWord consists of lowercase English letters.</span><br><span class="line">word in search consist of &#39;.&#39; or lowercase English letters.</span><br><span class="line">There will be at most 2 dots in word for search queries.</span><br><span class="line">At most 104 calls will be made to addWord and search.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Based on the idea of previous problem, we can use prefix tree to solve this problem. The only difference is that we need to consider the ‘.’ in the word. We can use recursive method to search the word in the tree. If we meet ‘.’, we need to search all the children of the current node. If the node we find is not correct, we need to move to the next node. If we run out of all 26 alphabet, we return false.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isCompleted;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="keyword">sizeof</span>(children));</span><br><span class="line">        isCompleted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span>   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root ;</span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        TrieNode * newroot = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> character: word)&#123;</span><br><span class="line">            <span class="keyword">int</span> alphabetIndex = character - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(newroot-&gt;children[alphabetIndex] == <span class="literal">NULL</span>)</span><br><span class="line">                newroot-&gt;children[alphabetIndex] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            newroot = newroot-&gt;children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        newroot -&gt; isCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> searchRecursive(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchRecursive</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; word, <span class="keyword">int</span> index, TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;isCompleted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> ch = word[index];</span><br><span class="line">        <span class="keyword">if</span>(ch != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[alphabetIndex] == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> searchRecursive(word, index + <span class="number">1</span>, node-&gt;children[alphabetIndex]);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;children[i] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (searchRecursive(word, index + <span class="number">1</span>, node-&gt;children[i]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Design/" rel="tag">Design</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hash-Table/" rel="tag">Hash Table</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Trie/" rel="tag">Trie</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1112"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/12/Leetcode1112/"
    >LLeetcode Study Day 46</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/12/Leetcode1112/" class="article-date">
  <time datetime="2023-11-12T10:38:51.000Z" itemprop="datePublished">2023-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Minimum-Genetic-Mutation"><a href="#Minimum-Genetic-Mutation" class="headerlink" title="Minimum Genetic Mutation"></a>Minimum Genetic Mutation</h1><p>A gene string can be represented by an 8-character long string, with choices from ‘A’, ‘C’, ‘G’, and ‘T’.</p>
<p>Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.</p>
<p>For example, “AACCGGTT” –&gt; “AACCGGTA” is one mutation.<br>There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.</p>
<p>Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.</p>
<p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: startGene &#x3D; &quot;AACCGGTT&quot;, endGene &#x3D; &quot;AACCGGTA&quot;, bank &#x3D; [&quot;AACCGGTA&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: startGene &#x3D; &quot;AACCGGTT&quot;, endGene &#x3D; &quot;AAACGGTA&quot;, bank &#x3D; [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">Output: 2</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; bank.length &lt;&#x3D; 10</span><br><span class="line">startGene.length &#x3D;&#x3D; endGene.length &#x3D;&#x3D; bank[i].length &#x3D;&#x3D; 8</span><br><span class="line">startGene, endGene, and bank[i] consist of only the characters [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;].</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I asked ChatGPT for get some hints and pseudo codes, in general, his idea is to use BFS to find the shortest path. He stored the bank gene into a set. Then use BFS to store and pop the mutated gene.</p>
<p>Here is his pseudo code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This problem can be approached as a graph traversal problem, where each gene string represents a node and a mutation is an edge between two nodes. The goal is to find the shortest path from the startGene to the endGene. Here&#39;s a step-by-step approach using Breadth-First Search (BFS), which is well-suited for finding the shortest path in unweighted graphs:</span><br><span class="line"></span><br><span class="line">Initialize: Create a queue for BFS and a set to keep track of visited nodes. Add the startGene to the queue.</span><br><span class="line"></span><br><span class="line">BFS Loop:</span><br><span class="line"></span><br><span class="line">While the queue is not empty, remove the first gene from the queue.</span><br><span class="line">Check if this gene is the endGene. If yes, return the number of mutations (depth) required to reach this gene.</span><br><span class="line">Otherwise, iterate over each character in the gene. For each character, try changing it to the other three possible nucleotides (&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;).</span><br><span class="line">For each modified gene, check if it is in the bank and not yet visited.</span><br><span class="line">If so, add it to the queue and mark it as visited.</span><br><span class="line">Return -1: If the queue gets empty and the endGene is not found, return -1, indicating no possible mutation path.</span><br></pre></td></tr></table></figure>
<p>Here’s a pseudo-code to illustrate this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pseudo</span><br><span class="line">function minGeneticMutation(startGene, endGene, bank):</span><br><span class="line">    if endGene not in bank:</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">    bankSet &#x3D; set(bank)</span><br><span class="line">    visited &#x3D; set()</span><br><span class="line">    queue &#x3D; [(startGene, 0)]  # (current gene, mutation steps)</span><br><span class="line"></span><br><span class="line">    while queue is not empty:</span><br><span class="line">        currentGene, steps &#x3D; queue.pop(0)</span><br><span class="line">        </span><br><span class="line">        if currentGene &#x3D;&#x3D; endGene:</span><br><span class="line">            return steps</span><br><span class="line"></span><br><span class="line">        for i in 0 to length(currentGene) - 1:</span><br><span class="line">            for nucleotide in [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]:</span><br><span class="line">                if nucleotide !&#x3D; currentGene[i]:</span><br><span class="line">                    mutatedGene &#x3D; currentGene[:i] + nucleotide + currentGene[i+1:]</span><br><span class="line">                    if mutatedGene in bankSet and mutatedGene not in visited:</span><br><span class="line">                        queue.append((mutatedGene, steps + 1))</span><br><span class="line">                        visited.add(mutatedGene)</span><br><span class="line"></span><br><span class="line">    return -1</span><br></pre></td></tr></table></figure>
<h3 id="Full-code"><a href="#Full-code" class="headerlink" title="Full code"></a>Full code</h3><p>Here is my code based on the pseudo code above, one thing I learnt is that we can use <code>substr</code> to split the string:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMutation</span><span class="params">(<span class="built_in">string</span> startGene, <span class="built_in">string</span> endGene, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">char</span>&gt; geneChar = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(find(bank.begin(), bank.end(), endGene) == bank.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; bankSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bank.size(); i++)</span><br><span class="line">            bankSet.insert(bank[i]);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; bankQ;</span><br><span class="line">        bankQ.push(&#123;startGene,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!bankQ.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> current = bankQ.front().first;</span><br><span class="line">            <span class="keyword">int</span> step = bankQ.front().second;</span><br><span class="line">            bankQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (current == endGene)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; current.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> singleGene: geneChar)&#123;</span><br><span class="line">                    <span class="built_in">string</span> mutatedGene = current.substr(<span class="number">0</span>, i) + singleGene + current.substr(i + <span class="number">1</span>, current.size());</span><br><span class="line">                    <span class="keyword">if</span> (bankSet.find(mutatedGene)!= bankSet.end() &amp;&amp; visited.find(mutatedGene) == visited.end())&#123;</span><br><span class="line">                        bankQ.push(&#123;mutatedGene, step+<span class="number">1</span>&#125;);</span><br><span class="line">                        visited.insert(mutatedGene);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h1><p>A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk such that:</p>
<p>Every adjacent pair of words differs by a single letter.<br>Every si for 1 &lt;= i &lt;= k is in wordList. Note that beginWord does not need to be in wordList.<br>sk == endWord<br>Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; beginWord.length &lt;&#x3D; 10</span><br><span class="line">endWord.length &#x3D;&#x3D; beginWord.length</span><br><span class="line">1 &lt;&#x3D; wordList.length &lt;&#x3D; 5000</span><br><span class="line">wordList[i].length &#x3D;&#x3D; beginWord.length</span><br><span class="line">beginWord, endWord, and wordList[i] consist of lowercase English letters.</span><br><span class="line">beginWord !&#x3D; endWord</span><br><span class="line">All the words in wordList are unique.</span><br></pre></td></tr></table></figure>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>The main idea is similar to the previous one, which is to use BFS to find the shortest path. The only difference is that this time we need to find the words with only one word difference between the original one, whereas the previous one is to try to replace each character with the four characters.</p>
<p>Here is my code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">difference</span><span class="params">(<span class="built_in">string</span> current, <span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; current.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i] != word[i])</span><br><span class="line">                diff ++;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(wordList.begin(), wordList.end(), endWord) == wordList.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)</span><br><span class="line">            wordSet.insert(wordList[i]);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; wordQ;</span><br><span class="line">        wordQ.push(&#123;beginWord,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!wordQ.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> current = wordQ.front().first;</span><br><span class="line">            <span class="keyword">int</span> step = wordQ.front().second;</span><br><span class="line">            wordQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (current == endWord)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">string</span> word: wordSet)&#123;</span><br><span class="line">                <span class="keyword">if</span> (difference(current, word) == <span class="number">1</span> &amp;&amp; visited.find(word) == visited.end())&#123;</span><br><span class="line">                    wordQ.push(&#123;word,step+<span class="number">1</span>&#125;);</span><br><span class="line">                    visited.insert(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hash-Table/" rel="tag">Hash Table</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1111-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/11/Leetcode1111-2/"
    >Leetcode Study Day 45</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/11/Leetcode1111-2/" class="article-date">
  <time datetime="2023-11-11T14:04:57.000Z" itemprop="datePublished">2023-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Snakes-and-Ladders"><a href="#Snakes-and-Ladders" class="headerlink" title="Snakes and Ladders"></a>Snakes and Ladders</h1><p>You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.</p>
<p>You start on square 1 of the board. In each move, starting from square curr, do the following:</p>
<p>Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].<br>This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.<br>If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.<br>The game ends when you reach the square n2.<br>A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.</p>
<p>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.</p>
<p>For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.<br>Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.</p>
<p><img src="image.png" alt="Alt text"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">In the beginning, you start at square 1 (at row 5, column 0).</span><br><span class="line">You decide to move to square 2 and must take the ladder to square 15.</span><br><span class="line">You then decide to move to square 17 and must take the snake to square 13.</span><br><span class="line">You then decide to move to square 14 and must take the ladder to square 35.</span><br><span class="line">You then decide to move to square 36, ending the game.</span><br><span class="line">This is the lowest possible number of moves to reach the last square, so return 4.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[-1,-1],[-1,3]]</span><br><span class="line">Output: 1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; board.length &#x3D;&#x3D; board[i].length</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 20</span><br><span class="line">board[i][j] is either -1 or in the range [1, n2].</span><br><span class="line">The squares labeled 1 and n2 do not have any ladders or snakes.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I found this <a target="_blank" rel="noopener" href="https://leetcode.com/problems/snakes-and-ladders/solutions/3092265/c-simple-bfs-with-full-explanation-beats-100/?envType=study-plan-v2&envId=top-interview-150">solution</a> from Leetcode. Here is his explanation:</p>
<blockquote>
<p>Intuition</p>
</blockquote>
<blockquote>
<p>The intuition behind this code is that it uses a breadth-first search (BFS) algorithm to find the minimum number of moves required to reach the last cell of the board from the first cell. BFS is an algorithm that explores all the vertices of a graph or all the nodes of a tree level by level.</p>
</blockquote>
<blockquote>
<p>Approach</p>
</blockquote>
<blockquote>
<p>The method starts by creating a vector of pairs called “cells” that stores the row and column of each cell in the board. It also creates a vector of integers called “dist” that stores the minimum number of moves required to reach each cell and initializes it to -1.</p>
</blockquote>
<blockquote>
<p>It then uses a queue to keep track of the cells to be visited and starts by pushing the first cell (cell 1) into the queue. The method then enters a while loop that continues until the queue is empty. In each iteration of the loop, it takes the front element of the queue, which is the current cell, and pops it from the queue.</p>
</blockquote>
<blockquote>
<p>For the current cell, the method loops through all the possible next cells which are from curr+1 to min(curr+6,n*n) (because in each move we can move to a dice roll max 6 steps) and checks if the minimum number of moves required to reach that cell has not been assigned yet. If it has not been assigned yet, the method assigns the minimum number of moves required to reach that cell as the minimum number of moves required to reach the current cell plus one. It also pushes the next cell into the queue to be visited in the next iteration.</p>
</blockquote>
<blockquote>
<p>The method then continues this process until all the cells have been visited, and the minimum number of moves required to reach each cell has been assigned. Finally, the method returns the minimum number of moves required to reach the last cell, which is stored in dist[n*n].</p>
</blockquote>
<blockquote>
<p>It also handles the case if there is a snake or ladder at the cell, it directly assigns the destination cell number as the cell number.</p>
</blockquote>
<blockquote>
<p>Complexity</p>
</blockquote>
<blockquote>
<p>Time complexity:</p>
</blockquote>
<blockquote>
<p>The time complexity of this code is O(n^2), where n is the size of the board. This is because the method uses a breadth-first search algorithm to traverse through each cell of the board and assigns the distance of each cell from the starting cell. The outer loop iterates n times, and the inner loop iterates n times, so the total number of iterations is n*n.</p>
</blockquote>
<blockquote>
<p>Note that this is assuming the queue and vector operations have a constant time complexity, which is typical but not guaranteed.</p>
</blockquote>
<blockquote>
<p>Space complexity:</p>
</blockquote>
<blockquote>
<p>The space complexity of this code is also O(n^2). This is because the method uses a vector of integers called “dist” to keep track of the minimum number of moves required to reach each cell, and this vector has nn elements. The method also uses a vector of pairs called “cells” to keep track of the row and column of each cell, and this vector also has nn elements. The method also uses a queue to keep track of the cells to be visited, which can have at most n*n elements.</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size(), lbl = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cells(n*n+<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">columns</span><span class="params">(n)</span></span>;</span><br><span class="line">        iota(columns.begin(), columns.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = n - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column : columns) &#123;</span><br><span class="line">                cells[lbl++] = &#123;row, column&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(columns.begin(), columns.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n*n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next = curr + <span class="number">1</span>; next &lt;= min(curr+<span class="number">6</span>, n*n); next++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [row, column] = cells[next];</span><br><span class="line">                <span class="keyword">int</span> destination = board[row][column] != <span class="number">-1</span> ? board[row][column] : next;</span><br><span class="line">                <span class="keyword">if</span> (dist[destination] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    dist[destination] = dist[curr] + <span class="number">1</span>;</span><br><span class="line">                    q.push(destination);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n*n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Matrix/" rel="tag">Matrix</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1111"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/11/Leetcode1111/"
    >Leetcode Study Day 45</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/11/Leetcode1111/" class="article-date">
  <time datetime="2023-11-11T13:59:01.000Z" itemprop="datePublished">2023-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Course-Schedule-II"><a href="#Course-Schedule-II" class="headerlink" title="Course Schedule II"></a>Course Schedule II</h1><p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.</p>
<p>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.<br>Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">Output: [0]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 2000</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; numCourses * (numCourses - 1)</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">ai !&#x3D; bi</span><br><span class="line">All the pairs [ai, bi] are distinct.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>The solution is similar to the previous question, except this time we add a stack to store the courses we want to take. After we find the courses that need to be taken in the end, we push them into the stack. After finding all the courses and make sure there is no cycle, we pop the stack and store the courses in the vector. The order of the courses is the reverse order of the stack. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">iscycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[], <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vis, <span class="keyword">int</span> id, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;courseStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[id] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[id] == <span class="number">0</span>)&#123;</span><br><span class="line">            vis[id] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> edge : adj[id])&#123;</span><br><span class="line">                <span class="keyword">if</span>(iscycle(adj, vis, edge, courseStack))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            courseStack.push(id);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[id] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pre)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge : pre)</span><br><span class="line">            adj[edge[<span class="number">1</span>]].push_back(edge[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; courseStack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(iscycle(adj, vis, i, courseStack))</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// Return empty if cycle is detected</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="keyword">while</span>(!courseStack.empty())&#123;</span><br><span class="line">            order.push_back(courseStack.top());</span><br><span class="line">            courseStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Topological-Sort/" rel="tag">Topological Sort</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1110-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/10/Leetcode1110-2/"
    >Leetcode Study Day 44</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/10/Leetcode1110-2/" class="article-date">
  <time datetime="2023-11-10T20:26:27.000Z" itemprop="datePublished">2023-11-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a>Course Schedule</h1><p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.</p>
<p>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.<br>Return true if you can finish all courses. Otherwise, return false.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0. So it is possible.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; numCourses &lt;&#x3D; 2000</span><br><span class="line">0 &lt;&#x3D; prerequisites.length &lt;&#x3D; 5000</span><br><span class="line">prerequisites[i].length &#x3D;&#x3D; 2</span><br><span class="line">0 &lt;&#x3D; ai, bi &lt; numCourses</span><br><span class="line">All the pairs prerequisites[i] are unique.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I found this <a target="_blank" rel="noopener" href="https://leetcode.com/problems/course-schedule/solutions/658275/c-dfs-easiest-solution-with-explanation-my-1st-approach/?envType=study-plan-v2&envId=top-interview-150">solution</a> from Leetcode. Here is his explanation:</p>
<blockquote>
<p>We just have to find if our graph contains cycle or not because if graph contains cycle then all tnodes in cycle are interdependent and 1 course cannot be completed because its prerequisite is dependent on other course and it goes on .<br>We used coloring algorithm to find if there is cycle in graph or not.</p>
</blockquote>
<blockquote>
<p>Coloring Algorithm</p>
</blockquote>
<blockquote>
<p>vis[id]=0 is used for node which is not yet visited, vis[id]=1 is used for the node which is visited and currently its child nodes are being visited and vis[id]=2 done when all the child nodes of a node (“id”) are visited and the function returns to parent node of node (“id”). So at that time it is marked as 2 because this node does not require any further traversing.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">iscycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[],<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vis,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="comment">// if we find this node again, we can make sure it&#x27;s a cycle</span></span><br><span class="line">        <span class="keyword">if</span>(vis[id]==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// if it&#x27;s a new node</span></span><br><span class="line">        <span class="keyword">if</span>(vis[id]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// we set it as 1</span></span><br><span class="line">            vis[id]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// we check all its adjacent nodes</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> edge : adj[id])&#123;</span><br><span class="line">                <span class="keyword">if</span>(iscycle(adj,vis,edge))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[id] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pre)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// a vector with n elements, each element is a vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge : pre)</span><br><span class="line">            <span class="comment">// push the pre[2]th number with course pre[1]</span></span><br><span class="line">            adj[edge[<span class="number">1</span>]].push_back(edge[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// a vector with n elements, each element is 0</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// if we find a cycle, return false</span></span><br><span class="line">            <span class="keyword">if</span>(iscycle(adj,vis,i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Topological-Sort/" rel="tag">Topological Sort</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1110"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/10/Leetcode1110/"
    >Leetcode Study Day 44</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/10/Leetcode1110/" class="article-date">
  <time datetime="2023-11-10T19:44:19.000Z" itemprop="datePublished">2023-11-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Evaluate-Division"><a href="#Evaluate-Division" class="headerlink" title="Evaluate Division"></a>Evaluate Division</h1><p>You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.</p>
<p>You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.</p>
<p>Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p>
<p>Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>
<p>Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values &#x3D; [2.0,3.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">Explanation: </span><br><span class="line">Given: a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0</span><br><span class="line">queries are: a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ? </span><br><span class="line">return: [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br><span class="line">note: x is undefined &#x3D;&gt; -1.0</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: equations &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values &#x3D; [1.5,2.5,5.0], queries &#x3D; [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span><br><span class="line">Output: [3.75000,0.40000,5.00000,0.20000]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: equations &#x3D; [[&quot;a&quot;,&quot;b&quot;]], values &#x3D; [0.5], queries &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span><br><span class="line">Output: [0.50000,2.00000,-1.00000,-1.00000]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; equations.length &lt;&#x3D; 20</span><br><span class="line">equations[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; Ai.length, Bi.length &lt;&#x3D; 5</span><br><span class="line">values.length &#x3D;&#x3D; equations.length</span><br><span class="line">0.0 &lt; values[i] &lt;&#x3D; 20.0</span><br><span class="line">1 &lt;&#x3D; queries.length &lt;&#x3D; 20</span><br><span class="line">queries[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; Cj.length, Dj.length &lt;&#x3D; 5</span><br><span class="line">Ai, Bi, Cj, Dj consist of lower case English letters and digits.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>For the solution, we use a nested map to record the graph. To be specific, we can imagine string <code>a</code> is a node, it map to string <code>b</code>, where the edge value is <code>a/b</code>, whcih is 1.5, it is the value that b mapped to. So we create a structure to store this nested map: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>Let me explain the code below:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create the nested map with input equations</span></span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; graph = createGraph(equations, values);</span><br><span class="line">        <span class="comment">// create the result vector</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="comment">// for each query, we find the path product</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (queries[i][<span class="number">0</span>] == queries[i][<span class="number">1</span>] &amp;&amp; graph.find(queries[i][<span class="number">0</span>]) != graph.end())</span><br><span class="line">                res.push_back(<span class="number">1.0</span>); <span class="comment">//Division of a number by itself</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (graph.find(queries[i][<span class="number">0</span>]) == graph.end() || graph.find(queries[i][<span class="number">1</span>]) == graph.end())</span><br><span class="line">                res.push_back(<span class="number">-1.0</span>); <span class="comment">// if we cannot find the node in the graph</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// we find the path product and push it to the result vector</span></span><br><span class="line">                <span class="keyword">double</span> result = findPathProduct(graph, queries[i][<span class="number">0</span>], queries[i][<span class="number">1</span>]);</span><br><span class="line">                res.push_back(result);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create graph function</span></span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; createGraph(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values)&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> value = values[i];</span><br><span class="line">            <span class="built_in">string</span> A = equations[i][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">string</span> B = equations[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// store the value in the nested map</span></span><br><span class="line">            graph[A][B] = value;</span><br><span class="line">            <span class="comment">// store the reverse value in the nested map</span></span><br><span class="line">            graph[B][A] = <span class="number">1.0</span> / value;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find path product function</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findPathProduct</span><span class="params">(<span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt;&amp; graph, <span class="built_in">string</span>&amp; start, <span class="built_in">string</span>&amp; end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// create a set to store the visited node</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="keyword">return</span> dfs(graph, start, end, <span class="number">1.0</span>, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DFS function</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt;&amp; graph, <span class="keyword">const</span> <span class="built_in">string</span>&amp; current, <span class="keyword">const</span> <span class="built_in">string</span>&amp; end, <span class="keyword">double</span> product, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">// if we have visited the node, we return -1.0</span></span><br><span class="line">        <span class="keyword">if</span>(visited.find(current)!= visited.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        <span class="comment">// if we find the end node, we return the product</span></span><br><span class="line">        <span class="keyword">if</span> (current == end)</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        <span class="comment">// we add the current node to the visited set</span></span><br><span class="line">        visited.insert(current);</span><br><span class="line">        <span class="comment">// for each neighbor of the current node, we find the path product</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="built_in">pair</span> : graph[current]) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">string</span>&amp; neighbor = <span class="built_in">pair</span>.first;</span><br><span class="line">            <span class="keyword">double</span> weight = <span class="built_in">pair</span>.second;</span><br><span class="line">            <span class="comment">// we use dfs to find the path product</span></span><br><span class="line">            <span class="keyword">double</span> pathProduct = dfs(graph, neighbor, end, product * weight, visited);</span><br><span class="line">            <span class="comment">// if we find the path product, we return it</span></span><br><span class="line">            <span class="keyword">if</span> (pathProduct != <span class="number">-1.0</span>)</span><br><span class="line">                <span class="keyword">return</span> pathProduct;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if we cannot find the path product, we return -1.0</span></span><br><span class="line">        visited.erase(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Shortest-Path/" rel="tag">Shortest Path</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Union-Find/" rel="tag">Union Find</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1109-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/09/Leetcode1109-2/"
    >Leetcode Study Day 43</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/09/Leetcode1109-2/" class="article-date">
  <time datetime="2023-11-09T11:41:35.000Z" itemprop="datePublished">2023-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h1><p>Given a reference of a node in a connected undirected graph.</p>
<p>Return a deep copy (clone) of the graph.</p>
<p>Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Test case format:</span><br><span class="line"></span><br><span class="line">For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with val &#x3D;&#x3D; 1, the second node with val &#x3D;&#x3D; 2, and so on. The graph is represented in the test case using an adjacency list.</span><br><span class="line"></span><br><span class="line">An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</span><br><span class="line"></span><br><span class="line">The given node will always be the first node with val &#x3D; 1. You must return the copy of the given node as a reference to the cloned graph.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt="graph"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val &#x3D; 1)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">2nd node (val &#x3D; 2)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br><span class="line">3rd node (val &#x3D; 3)&#39;s neighbors are 2nd node (val &#x3D; 2) and 4th node (val &#x3D; 4).</span><br><span class="line">4th node (val &#x3D; 4)&#39;s neighbors are 1st node (val &#x3D; 1) and 3rd node (val &#x3D; 3).</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: adjList &#x3D; [[]]</span><br><span class="line">Output: [[]]</span><br><span class="line">Explanation: Note that the input contains one empty list. The graph consists of only one node with val &#x3D; 1 and it does not have any neighbors.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: adjList &#x3D; []</span><br><span class="line">Output: []</span><br><span class="line">Explanation: This an empty graph, it does not have any nodes.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">The number of nodes in the graph is in the range [0, 100].</span><br><span class="line">1 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br><span class="line">Node.val is unique for each node.</span><br><span class="line">There are no repeated edges and no self-loops in the graph.</span><br><span class="line">The Graph is connected and all nodes can be visited starting from the given node.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>The <a target="_blank" rel="noopener" href="https://leetcode.com/problems/clone-graph/solutions/1792834/c-easy-explanation-dfs/?envType=study-plan-v2&envId=top-interview-150">solution</a> from Leetcode used DFS to solve this question. Here is the full explanation:</p>
<h3 id="OBSERVATIONS"><a href="#OBSERVATIONS" class="headerlink" title="OBSERVATIONS"></a>OBSERVATIONS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. Cloned Graph has all nodes as newnodes and don&#39;t have node as reference to given original graph.</span><br><span class="line">2. Graph has no practical edges, i.e no pointers for edges.</span><br><span class="line">         (2,3)            (1,3)&lt;---adj list</span><br><span class="line">		  (1)-------------(2)</span><br><span class="line">		    |              |</span><br><span class="line">			|              |</span><br><span class="line">			|              |</span><br><span class="line">		  (4)-------------(3)</span><br><span class="line">		  (1,3)          (2,4)</span><br><span class="line">If i say &#39;1&#39; is my starting point and how should i jump to &#39;2&#39; for that i have to iterate through this adjacency list.</span><br><span class="line">ALGORITHM TO USE</span><br><span class="line">We need to traverse all node of original graph and as soon as we reach a node, we will make a copy node.</span><br><span class="line">And recur for rest of the graph.</span><br><span class="line">This is a typical recursion type problem implemented on Graph.</span><br><span class="line">For &#39;Recursion&#39; we use basically &#39;DFS&#39; or &#39;BFS&#39;.</span><br><span class="line">I am using DFS</span><br></pre></td></tr></table></figure>
<h3 id="KEY-POINTS"><a href="#KEY-POINTS" class="headerlink" title="KEY POINTS"></a>KEY POINTS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. We use HashMap to solve it and using DFS.</span><br><span class="line">2. Initially our hash map will be empty and we try to map the old node with the new node or the copy node.</span><br><span class="line">3. We start with any entry point.</span><br><span class="line">4. I am using &#39;1&#39; as my entry point.</span><br><span class="line"></span><br><span class="line">Now lets see how its going i am starting with 1 and whenever i visited a new node i coloned it and put in there.</span><br><span class="line">We are using DFS so algorithm is like &#39;it starts at the root node (select some arbitrary node as root node in the case of a graph) and explores as far as possible along each branch before backtracking.</span><br><span class="line">So the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacentunmarked node and continue this loop until there is no unmarked adjacent node. </span><br><span class="line">Then backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the path.&#39;</span><br><span class="line">So we are using HashMap to put all the visited node or old node there with clone one to.</span><br><span class="line"> _________</span><br><span class="line">| HashMap |</span><br><span class="line"> ----------</span><br><span class="line">|Old|Clone| </span><br><span class="line">| 1  | 1 |</span><br><span class="line">|  2 | 2 |</span><br><span class="line">|  3 | 3 |                                                     </span><br><span class="line">|  4 | 4 |                                                                                                            </span><br><span class="line">---------</span><br><span class="line"></span><br><span class="line">Now i started with 1 so i cloned it and from 1 can go to 2 and 4 so i go 2 and when i visited 2 i cloned 2 and now fro  i have two choices either go to previous one that is 1 or discover 3 i.e new node</span><br><span class="line">so accordingly to dfs i go to 3 and from 3 i can go to 4 i go there and cloned it. Now if we see fro each node we have viisted to a new node but what about 4. So here half part of Dfs is completed,</span><br><span class="line">and now its time for recursive call to go back and now from here we check from current node i can go where and where.</span><br><span class="line">And follow the same rules over there.</span><br><span class="line"></span><br><span class="line">BUT BEFORE STARTING ANY CLONING WE HAVE TO CHECK THAT IF WE HAVE CLONED THAT NODE ALREADY THERE OR NOT. IF NOT THAN ONLY WE CLONED IT. </span><br><span class="line"></span><br><span class="line">Thats the only reason we are using hash map so that we don&#39;t need to clone again and again.</span><br><span class="line">For every uncloned node we make a clone and iterate over the neighbors of original node using dfs traversal or </span><br></pre></td></tr></table></figure>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* cur,<span class="built_in">unordered_map</span>&lt;Node*,Node*&gt;&amp; mp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; neighbour;</span><br><span class="line">        Node* clone=<span class="keyword">new</span> Node(cur-&gt;val);</span><br><span class="line">        mp[cur]=clone;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it:cur-&gt;neighbors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.find(it)!=mp.end())   <span class="comment">//already clone and stored in map</span></span><br><span class="line">                &#123;</span><br><span class="line">                    neighbour.push_back(mp[it]);    <span class="comment">//directly push back the clone node from map to neigh</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    neighbour.push_back(dfs(it,mp));</span><br><span class="line">            &#125;</span><br><span class="line">            clone-&gt;neighbors=neighbour;</span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; mp;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;neighbors.size()==<span class="number">0</span>)   <span class="comment">//if only one node present no neighbors</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* clone= <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> clone; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(node,mp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Graph/" rel="tag">Graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hash-Table/" rel="tag">Hash Table</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1109"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/09/Leetcode1109/"
    >Leetcode Study Day 43</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/09/Leetcode1109/" class="article-date">
  <time datetime="2023-11-09T11:38:36.000Z" itemprop="datePublished">2023-11-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Surrounded-Regions"><a href="#Surrounded-Regions" class="headerlink" title="Surrounded Regions"></a>Surrounded Regions</h1><p>Given an m x n matrix board containing ‘X’ and ‘O’, capture all regions that are 4-directionally surrounded by ‘X’.<br>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Explanation: Notice that an &#39;O&#39; should not be flipped if:</span><br><span class="line">- It is on the border, or</span><br><span class="line">- It is adjacent to an &#39;O&#39; that should not be flipped.</span><br><span class="line">The bottom &#39;O&#39; is on the border, so it is not flipped.</span><br><span class="line">The other three &#39;O&#39; form a surrounded region, so they are flipped.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; board.length</span><br><span class="line">n &#x3D;&#x3D; board[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 200</span><br><span class="line">board[i][j] is &#39;X&#39; or &#39;O&#39;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>The solution is like the island problem. We use DFS to solve this question.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=m <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> board[i][j] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        DFS(board, i<span class="number">-1</span>, j, m, n);</span><br><span class="line">        DFS(board, i+<span class="number">1</span>, j, m, n);</span><br><span class="line">        DFS(board, i, j<span class="number">-1</span>, m, n);</span><br><span class="line">        DFS(board, i, j+<span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//We will use boundary DFS to solve this problem</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// Let&#x27;s analyze when an &#x27;O&#x27; cannot be flipped,</span></span><br><span class="line">      <span class="comment">// if it has atleast one &#x27;O&#x27; in it&#x27;s adjacent, AND ultimately this chain of adjacent &#x27;O&#x27;s is connected to some &#x27;O&#x27; which lies on boundary of board</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//consider these two cases for clarity :</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        O&#x27;s won&#x27;t be flipped          O&#x27;s will be flipped</span></span><br><span class="line"><span class="comment">        [X O X X X]                   [X X X X X]     </span></span><br><span class="line"><span class="comment">        [X O O O X]                   [X O O O X]</span></span><br><span class="line"><span class="comment">        [X O X X X]                   [X O X X X] </span></span><br><span class="line"><span class="comment">        [X X X X X]                   [X X X X X]</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      So we can conclude if a chain of adjacent O&#x27;s is connected some O on boundary then they cannot be flipped</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//Steps to Solve :</span></span><br><span class="line">      <span class="comment">//1. Move over the boundary of board, and find O&#x27;s </span></span><br><span class="line">      <span class="comment">//2. Every time we find an O, perform DFS from it&#x27;s position</span></span><br><span class="line">      <span class="comment">//3. In DFS convert all &#x27;O&#x27; to &#x27;#&#x27;      (why?? so that we can differentiate which &#x27;O&#x27; can be flipped and which cannot be)   </span></span><br><span class="line">      <span class="comment">//4. After all DFSs have been performed, board contains three elements,#,O and X</span></span><br><span class="line">      <span class="comment">//5. &#x27;O&#x27; are left over elements which are not connected to any boundary O, so flip them to &#x27;X&#x27;</span></span><br><span class="line">      <span class="comment">//6. &#x27;#&#x27; are elements which cannot be flipped to &#x27;X&#x27;, so flip them back to &#x27;O&#x27;</span></span><br><span class="line">      <span class="comment">//7. finally, Upvote the solution😊   </span></span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">     <span class="keyword">int</span> m = board.size();</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span>;  </span><br><span class="line">        </span><br><span class="line">     <span class="keyword">int</span> n = board[<span class="number">0</span>].size();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//Moving over firts and last column   </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">             DFS(board, i, <span class="number">0</span>, m, n);</span><br><span class="line">         <span class="keyword">if</span>(board[i][n<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">             DFS(board, i, n<span class="number">-1</span>, m, n);</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">     <span class="comment">//Moving over first and last row   </span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span>(board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">             DFS(board, <span class="number">0</span>, j, m, n);</span><br><span class="line">         <span class="keyword">if</span>(board[m<span class="number">-1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">             DFS(board, m<span class="number">-1</span>, j, m, n);</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                 board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">             <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                 board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Matrix/" rel="tag">Matrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Union-Find/" rel="tag">Union Find</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1108-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/08/Leetcode1108-2/"
    >Leetcode Study Day 42</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/08/Leetcode1108-2/" class="article-date">
  <time datetime="2023-11-08T09:43:57.000Z" itemprop="datePublished">2023-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h1><p>Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands.</p>
<p>An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: grid &#x3D; [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; grid.length</span><br><span class="line">n &#x3D;&#x3D; grid[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 300</span><br><span class="line">grid[i][j] is &#39;0&#39; or &#39;1&#39;.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I saw a wonderful <a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/solutions/56340/python-simple-dfs-solution/?envType=study-plan-v2&envId=top-interview-150">solution</a> using DFS to solve this question in python. I convert it into C++ version.</p>
<p>In this code, we frist iterate the grid from the top left corner to the bottom right corner. If we find a ‘1’, we use dfs to find all the adjacent ‘1’ and change them into ‘#’. Then we increase the count by 1. Finally, we return the count.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span> || i &gt;= grid.size() || j &gt;= grid[<span class="number">0</span>].size() || grid[i][j]!= <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i<span class="number">-1</span>, j);</span><br><span class="line">        dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid, i, j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Matrix/" rel="tag">Matrix</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Union-Find/" rel="tag">Union Find</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1108"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/08/Leetcode1108/"
    >Leetcode Study Day 42</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/08/Leetcode1108/" class="article-date">
  <time datetime="2023-11-08T09:29:13.000Z" itemprop="datePublished">2023-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a>Validate Binary Search Tree</h1><p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>A valid BST is defined as follows:</p>
<p>The left<br>subtree<br> of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: root &#x3D; [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">The number of nodes in the tree is in the range [1, 104].</span><br><span class="line">-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg"></p>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>My solution is initialise a NodeTree variable called prev. Then we use in-order traverse to traverse the tree. If the previous node value is larger or equal to the current node value, then we return false. Otherwise, we return true.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root -&gt; left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">nullptr</span> &amp;&amp; prev -&gt; val &gt;= root -&gt; val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="keyword">return</span> (isValidBST(root -&gt; right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary-Search-Tree/" rel="tag">Binary Search Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary-Tree/" rel="tag">Binary Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Depth-First-Search/" rel="tag">Depth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/">Next Page</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2023
        <i class="ri-heart-fill heart_icon"></i> Yangyang Cui
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Yangyang"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>

</html>