<!DOCTYPE html>


<html lang="zh-CN,en,default">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="share everything I want to share" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Yangyang</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon2.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/yangocean-sudo"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/wall_paper_code_sleep.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Yangyang</a></h1>
      <div id="subtitle-box">
        
          <span id="subtitle">Think. Learn. Create</span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>




<!-- Subtitle -->

<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Try to update hard.</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Leetcode0202"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/02/02/Leetcode0202/"
    >Leetcode Study Day 54</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/02/02/Leetcode0202/" class="article-date">
  <time datetime="2024-02-02T22:56:16.000Z" itemprop="datePublished">2024-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a>Search Insert Position</h1><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= nums.length &lt;= 10^4</span><br><span class="line">-10^4 &lt;= nums[i] &lt;= 10^4</span><br><span class="line">nums contains distinct values sorted in ascending order.</span><br><span class="line">-10^4 &lt;= target &lt;= 10^4</span><br></pre></td></tr></table></figure>
<h2 id="Binary-Search-Solution"><a href="#Binary-Search-Solution" class="headerlink" title="Binary Search Solution"></a>Binary Search Solution</h2><p>We first initialise two pointers, <code>left</code> and <code>right</code>. <code>left</code> is the index of the first element in the array, <code>right</code> is the index of the last element in the array. Then we iterate through the array and update the <code>left</code> and <code>right</code> pointers. If the target is found, we return the index. If the target is not found, we return the index where it would be if it were inserted in order.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> m = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] == target)</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target)&#123;</span><br><span class="line">                right = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> left= m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] &lt; target ? left + <span class="number">1</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a>Search a 2D Matrix</h1><p>You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h2 id="Binary-Search-Solution-1"><a href="#Binary-Search-Solution-1" class="headerlink" title="Binary Search Solution"></a>Binary Search Solution</h2><p>We use binary search twice to find the answer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bottom = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &lt;= bottom)&#123;</span><br><span class="line">            <span class="type">int</span> m = top+ (bottom-top)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[m][<span class="number">0</span>] &lt; target)</span><br><span class="line">                top = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[m][<span class="number">0</span>] &gt; target)</span><br><span class="line">                bottom = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> row = bottom;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt;= right;)&#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][middle] &lt; target)</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][middle] &gt; target)</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary-Search/" rel="tag">Binary Search</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode0130"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/30/Leetcode0130/"
    >Leetcode Study Day 51 and 52</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/30/Leetcode0130/" class="article-date">
  <time datetime="2024-01-30T16:16:07.000Z" itemprop="datePublished">2024-01-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h1><p>Given the head of a linked list, return the list after sorting it in ascending order.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,2,1,3]</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [-1,5,3,4,0]</span><br><span class="line">Output: [-1,0,3,4,5]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: head = []</span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">The number of nodes in the list is in the range [0, 5 * 104].</span><br><span class="line">-105 &lt;= Node.val &lt;= 105</span><br></pre></td></tr></table></figure>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>My solution actually doesn’t apply the divide and conquer method. I push each value in the node into a list and then sort it first. Then I create a new linked list and push the sorted list into the linked list. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; storeValue;</span><br><span class="line">        ListNode * current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            storeValue.<span class="built_in">push_back</span>(current-&gt;val);</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(storeValue.<span class="built_in">begin</span>(), storeValue.<span class="built_in">end</span>());</span><br><span class="line">        ListNode * newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(storeValue[<span class="number">0</span>]);</span><br><span class="line">        ListNode * newCurrent = newHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; storeValue.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            ListNode * nextNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(storeValue[i]);</span><br><span class="line">            newCurrent -&gt; next= nextNode;</span><br><span class="line">            newCurrent = newCurrent -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h2><p>I found one good explanation from the <a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/solutions/1795126/c-merge-sort-2-pointer-easy-to-understand/?envType=study-plan-v2&envId=top-interview-150">LeetCode</a>.</p>
<p>The idea is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Using 2pointer / fast-slow pointer find the middle node of the list.</span><br><span class="line">2. Now call mergeSort for 2 halves.</span><br><span class="line">3. Merge the Sort List (divide and conqueror Approach)</span><br></pre></td></tr></table></figure>
<p>The code is :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//If List Contain a Single or 0 Node</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head -&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ListNode *temp = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 pointer appraoach / turtle-hare Algorithm (Finding the middle element)</span></span><br><span class="line">        <span class="keyword">while</span>(fast !=  <span class="literal">NULL</span> &amp;&amp; fast -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = slow;</span><br><span class="line">            slow = slow-&gt;next;          <span class="comment">//slow increment by 1</span></span><br><span class="line">            fast = fast -&gt;next -&gt;next;  <span class="comment">//fast incremented by 2</span></span><br><span class="line">            </span><br><span class="line">        &#125;   </span><br><span class="line">        temp -&gt; next = <span class="literal">NULL</span>;            <span class="comment">//end of first left half</span></span><br><span class="line">        </span><br><span class="line">        ListNode* l1 = <span class="built_in">sortList</span>(head);    <span class="comment">//left half recursive call</span></span><br><span class="line">        ListNode* l2 = <span class="built_in">sortList</span>(slow);    <span class="comment">//right half recursive call</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergelist</span>(l1, l2);         <span class="comment">//mergelist Function call</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MergeSort Function O(n*logn)</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergelist</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *ptr = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *curr = ptr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                curr -&gt; next = l1;</span><br><span class="line">                l1 = l1 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curr -&gt; next = l2;</span><br><span class="line">                l2 = l2 -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        curr = curr -&gt;next;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//for unqual length linked list</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr -&gt; next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            curr -&gt; next = l2;</span><br><span class="line">            l2 = l2 -&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Divide-and-Conquer/" rel="tag">Divide and Conquer</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1116-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/16/Leetcode1116-2/"
    >Leetcode Study Day 50</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/16/Leetcode1116-2/" class="article-date">
  <time datetime="2023-11-16T09:56:57.000Z" itemprop="datePublished">2023-11-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted Array to Binary Search Tree"></a>Convert Sorted Array to Binary Search Tree</h1><p>Given an integer array nums where the elements are sorted in ascending order, convert it to a<br>height-balanced binary search tree.</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,3]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</span><br><span class="line">nums is sorted in a strictly increasing order.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg"></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>We use a recursion method to create the tree. Firstly, we find the median of the array and create a node with the median. Then we call the function recursively to create the left and right subtree. The left subtree is created by the left half of the array and the right subtree is created by the right half of the array.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> medianInd = nums.size() / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[medianInd]);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(nums.begin(),nums.begin()+medianInd)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(nums.begin()+medianInd+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">        root -&gt; left = sortedArrayToBST(left);</span><br><span class="line">        root -&gt; right = sortedArrayToBST(right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary-Search-Tree/" rel="tag">Binary Search Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary-Tree/" rel="tag">Binary Tree</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Divide-and-Conquer/" rel="tag">Divide and Conquer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1116"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/16/Leetcode1116/"
    >Leetcode Study Day 50</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/16/Leetcode1116/" class="article-date">
  <time datetime="2023-11-16T09:50:45.000Z" itemprop="datePublished">2023-11-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="N-Queens-II"><a href="#N-Queens-II" class="headerlink" title="N-Queens II"></a>N-Queens II</h1><p>The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.</p>
<p>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: n &#x3D; 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two distinct solutions to the 4-queens puzzle as shown.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: n &#x3D; 1</span><br><span class="line">Output: 1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 9</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>This is a backtracking problem. We can use a vector to store the position of the queens. The index of the vector represents the row and the value represents the column. We can use a function to check if the current position is valid. If it is valid, we can add it to the vector and call the function recursively. If the size of the vector is equal to n, we can add it to the result. Otherwise, we can remove the last element of the vector and try another position.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSafe</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i] == col <span class="keyword">or</span> <span class="built_in">abs</span>(board[i] - col) == <span class="built_in">abs</span>(i - row))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solveNQueens</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; board, <span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n)&#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isSafe(board, row, col, n))&#123;</span><br><span class="line">                board[row] = col;</span><br><span class="line">                count = solveNQueens(board, row + <span class="number">1</span>, n, count);</span><br><span class="line">                board[row] = - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; board (n, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> solveNQueens(board, <span class="number">0</span>, n, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Variable-explanation"><a href="#Variable-explanation" class="headerlink" title="Variable explanation"></a>Variable explanation</h2><p>In the N-Queens solution, the <code>board</code> array and the <code>row</code> and <code>col</code> variables in the recursion have specific meanings that are crucial to understanding how the algorithm works. Let’s clarify these:</p>
<ol>
<li><p><strong>The <code>board</code> Array</strong>:</p>
<ul>
<li>The <code>board</code> array is a 1D vector of size <code>n</code>, where <code>n</code> is the size of the chessboard (n x n).</li>
<li>Each element of the <code>board</code> array represents a row on the chessboard.</li>
<li>The value stored at each index of the <code>board</code> array represents the column position where a queen is placed in that row.</li>
<li>For example, if <code>board[2] = 3</code>, it means that in row 2, a queen is placed in column 3.</li>
</ul>
</li>
<li><p><strong>The <code>row</code> Variable</strong>:</p>
<ul>
<li>The <code>row</code> variable in the <code>solveNQueens</code> function represents the current row on the chessboard where you are trying to place a queen.</li>
<li>It is used to iterate through the rows of the chessboard, starting from 0 up to <code>n-1</code>.</li>
</ul>
</li>
<li><p><strong>The <code>col</code> Variable</strong>:</p>
<ul>
<li>The <code>col</code> variable in the <code>solveNQueens</code> function represents the column position in the current row where you are attempting to place a queen.</li>
<li>For each row, you try placing a queen in each column (from 0 to <code>n-1</code>) and check if it’s a safe placement.</li>
</ul>
</li>
<li><p><strong>The <code>isSafe</code> Function</strong>:</p>
<ul>
<li>This function checks whether placing a queen at the <code>board[row] = col</code> position is safe.</li>
<li>It checks for conflicts with queens in previous rows. There are two types of conflicts:<ul>
<li>Column conflict: If any previous row (<code>i</code>) has a queen in the same column (<code>board[i] == col</code>).</li>
<li>Diagonal conflict: If any previous row (<code>i</code>) has a queen positioned diagonally. This is checked by the condition <code>abs(board[i] - col) == abs(i - row)</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Backtracking and Recursion</strong>:</p>
<ul>
<li>The <code>solveNQueens</code> function uses recursion to try placing queens row by row.</li>
<li>If a safe position is found for a queen in the current row, it moves to the next row.</li>
<li>If no safe position is found in a row, it backtracks (i.e., it goes back to the previous row and tries a different column for the queen in that row).</li>
</ul>
</li>
</ol>
<p>In summary, the <code>board</code> array is a compact way to represent the positions of queens on the chessboard, and the <code>row</code> and <code>col</code> variables are used to navigate through the chessboard to place the queens safely. The algorithm explores all possible ways to place the queens, backtracking when necessary, until all solutions are found.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Backtracking/" rel="tag">Backtracking</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1115"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/15/Leetcode1115/"
    >Leetcode Study Day 49</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/15/Leetcode1115/" class="article-date">
  <time datetime="2023-11-15T17:51:44.000Z" itemprop="datePublished">2023-11-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h1><p>Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].</p>
<p>You may return the answer in any order.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span><br><span class="line">Explanation: There are 4 choose 2 &#x3D; 6 total combinations.</span><br><span class="line">Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: n &#x3D; 1, k &#x3D; 1</span><br><span class="line">Output: [[1]]</span><br><span class="line">Explanation: There is 1 choose 1 &#x3D; 1 total combination.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 20</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>To solve this problem, we can use a technique called backtracking, which is a form of recursion. Backtracking is particularly useful for problems where you need to explore multiple possibilities and combinations, like in this case where we want to find all possible combinations of k numbers from the range [1, n].</p>
<p>In this backtracking function, if the combination has k numbers, add it to the result and return. Iterate from the current number to n and recursively call the function with the next number. Backtrack: Remove the last added number to try a new combination.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">combine</span><span class="params">(n, k)</span>:</span></span><br><span class="line"><span class="function">    result </span>= []</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">backtrack</span><span class="params">(start, combination)</span>:</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">length</span><span class="params">(combination)</span> </span>== k:</span><br><span class="line">            result.add(combination.copy())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i from start to n:</span><br><span class="line">            combination.add(i)</span><br><span class="line">            backtrack(i + <span class="number">1</span>, combination)</span><br><span class="line">            combination.removeLast()</span><br><span class="line"></span><br><span class="line">    backtrack(<span class="number">1</span>, [])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h1><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [0,1]</span><br><span class="line">Output: [[0,1],[1,0]]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: nums &#x3D; [1]</span><br><span class="line">Output: [[1]]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 6</span><br><span class="line">-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10</span><br><span class="line">All the integers of nums are unique.</span><br></pre></td></tr></table></figure>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>The key difference between combinations and permutations is that in permutations, the order matters. Therefore, I need to ensure that each number is used exactly once in each permutation, but in every possible order.</p>
<p>To check if a number is already used in the current permutation, I use a bool array to record each number’s status. If the number is used, I skip it. After call the recursion function, I pop the last number from the current permutation to try the next number and change the status of the current number to unused.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;  ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; single, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single.size() == nums.size())&#123;</span><br><span class="line">            ans.push_back(single);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            single.push_back(nums[i]);</span><br><span class="line">            backtrack(index + <span class="number">1</span>, single, nums, used);</span><br><span class="line">            single.pop_back();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; single;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">// To keep track of used elements</span></span><br><span class="line">        backtrack(<span class="number">0</span>, single, nums, used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Backtracking/" rel="tag">Backtracking</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1114-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/14/Leetcode1114-2/"
    >Leetcode Study Day 48</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/14/Leetcode1114-2/" class="article-date">
  <time datetime="2023-11-14T22:39:34.000Z" itemprop="datePublished">2023-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Word-Search-II"><a href="#Word-Search-II" class="headerlink" title="Word Search II"></a>Word Search II</h1><p>Given an m x n board of characters and a list of strings words, return all words on the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words &#x3D; [&quot;abcb&quot;]</span><br><span class="line">Output: []</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">m &#x3D;&#x3D; board.length</span><br><span class="line">n &#x3D;&#x3D; board[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 12</span><br><span class="line">board[i][j] is a lowercase English letter.</span><br><span class="line">1 &lt;&#x3D; words.length &lt;&#x3D; 3 * 104</span><br><span class="line">1 &lt;&#x3D; words[i].length &lt;&#x3D; 10</span><br><span class="line">words[i] consists of lowercase English letters.</span><br><span class="line">All the strings of words are unique.</span><br></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg"></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>This question is like a combination of island question and prefix tree. Let’s explain the code line by line:</p>
<p>This C++ code defines a class <code>Solution</code> that implements a solution to the “Word Search II” problem using a Trie data structure and Depth-First Search (DFS). The problem involves finding all words from a given list that can be formed by sequentially adjacent letters on a board.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    TrieNode *children[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line"></span><br><span class="line">    TrieNode() : word(<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>This is a definition of a <code>TrieNode</code> structure. Each node has 26 children (one for each letter of the alphabet) and a string <code>word</code>. The constructor initializes <code>word</code> to an empty string and all children pointers to <code>nullptr</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>This function, <code>findWords</code>, is the main function of the class. It takes a 2D character vector <code>board</code> and a vector of strings <code>words</code> as input.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrieNode *root = buildTrie(words);</span><br></pre></td></tr></table></figure>
<ul>
<li>Here, a Trie is built from the list of words using the <code>buildTrie</code> function.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br></pre></td></tr></table></figure>
<ul>
<li>This line initializes a vector <code>result</code> to store the words found on the board.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">        dfs(board, i, j, root, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>These lines iterate over each cell of the board and call the <code>dfs</code> (Depth-First Search) function for each cell.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Returns the vector <code>result</code> containing all the words found on the board.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TrieNode *<span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>This function, <code>buildTrie</code>, creates a Trie from the given list of words.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrieNode *root = <span class="keyword">new</span> TrieNode();</span><br></pre></td></tr></table></figure>
<ul>
<li>Creates a new TrieNode that will serve as the root of the Trie.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words.size(); j++) &#123;</span><br><span class="line">    <span class="built_in">string</span> word = words[j];</span><br><span class="line">    TrieNode *curr = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;children[c] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curr-&gt;children[c] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr-&gt;children[c];</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;word = word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>This loop inserts each word into the Trie. For each character in a word, it checks if the corresponding child node exists; if not, it creates a new node. After inserting all characters of a word, it sets the <code>word</code> field of the last node.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Returns the root of the Trie.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode *p, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<ul>
<li>This function, <code>dfs</code>, performs a depth-first search on the board starting from the cell <code>(i, j)</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = board[i][j];</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span> || !p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>This checks if the current cell is already visited (marked as ‘#’) or if there is no child in the Trie corresponding to the current character. If either is true, it returns immediately.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>Moves to the child node corresponding to the current character.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p-&gt;word.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result.push_back(p-&gt;word);</span><br><span class="line">    p-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>If the current Trie node has a word (i.e., we have found a word), it adds the word to the result and clears the word in the Trie node to avoid duplicates.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Marks the current cell as visited.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j, p, result);</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, p, result);</span><br><span class="line"><span class="keyword">if</span> (i &lt; board.size() - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, p, result);</span><br><span class="line"><span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, p, result);</span><br></pre></td></tr></table></figure>
<ul>
<li>These lines recursively call <code>dfs</code> for all four adjacent cells (up, left, down, right), if they are within the bounds of the board.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    board[i][j] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Restores the current cell’s original character (unmarking it as visited).</li>
</ul>
<p>This code efficiently searches for words on a board using Trie and DFS, which is a great demonstration of your understanding of advanced data structures and algorithms. </p>
<h2 id="How-Word-stored-in-Trie"><a href="#How-Word-stored-in-Trie" class="headerlink" title="How Word stored in Trie"></a>How Word stored in Trie</h2><p>In the given implementation of the Trie (prefix tree), the complete word is stored in the last node of its corresponding path. Here’s how it works:</p>
<ol>
<li><p><strong>Trie Structure</strong>: Each node in the Trie represents a single character. The root node typically represents an empty string, and each path from the root to a node represents a prefix of some word.</p>
</li>
<li><p><strong>Storing Words</strong>: As you insert a word into the Trie, you create a path where each character of the word corresponds to a node. When you reach the end of the word, you store the entire word at the last node in this path.</p>
</li>
<li><p><strong>Why Store the Whole Word</strong>: Storing the entire word at the last node is particularly useful for applications like the word search problem. When you traverse the Trie during the search, reaching a node with a non-empty <code>word</code> field immediately tells you that you’ve found a valid word. This approach eliminates the need to reconstruct the word from the path you’ve traversed.</p>
</li>
<li><p><strong>Example</strong>: Suppose you insert the word “cat” into an empty Trie. You’ll create nodes for ‘c’, ‘a’, and ‘t’. At the ‘t’ node, you’ll store the entire word “cat”. If you later insert “car”, you’ll add an ‘r’ node after the ‘a’ node (which is shared with “cat”), and store “car” at the ‘r’ node.</p>
</li>
</ol>
<p>This method is efficient for word search problems because it allows for quick and direct identification of complete words during the traversal of the Trie.</p>
<h2 id="Full-code"><a href="#Full-code" class="headerlink" title="Full code"></a>Full code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *children[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">string</span> word;</span><br><span class="line"></span><br><span class="line">        TrieNode() : word(<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                children[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span> </span>&#123;</span><br><span class="line">        TrieNode *root = buildTrie(words);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                dfs(board, i, j, root, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function">TrieNode *<span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span> </span>&#123;</span><br><span class="line">        TrieNode *root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words.size(); j++) &#123;</span><br><span class="line">            <span class="built_in">string</span> word = words[j];</span><br><span class="line">            TrieNode *curr = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;children[c] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    curr-&gt;children[c] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr-&gt;children[c];</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;word = word;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, TrieNode *p, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span> || !p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span>;</span><br><span class="line">        p = p-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;word.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.push_back(p-&gt;word);</span><br><span class="line">            p-&gt;word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dfs(board, i - <span class="number">1</span>, j, p, result);</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dfs(board, i, j - <span class="number">1</span>, p, result);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; board.size() - <span class="number">1</span>) dfs(board, i + <span class="number">1</span>, j, p, result);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span>) dfs(board, i, j + <span class="number">1</span>, p, result);</span><br><span class="line">        board[i][j] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1114"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/14/Leetcode1114/"
    >Leetcode Study Day 48</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/14/Leetcode1114/" class="article-date">
  <time datetime="2023-11-14T22:18:53.000Z" itemprop="datePublished">2023-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h1><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: digits &#x3D; &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: digits &#x3D; &quot;&quot;</span><br><span class="line">Output: []</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: digits &#x3D; &quot;2&quot;</span><br><span class="line">Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; digits.length &lt;&#x3D; 4</span><br><span class="line">digits[i] is a digit in the range [&#39;2&#39;, &#39;9&#39;].</span><br></pre></td></tr></table></figure>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>My solution is to use a recursive function with index as the parameter. When the index is equal to the length of the digits, we append the current string to the result. Otherwise, we loop through the letters of the current digit and call the recursive function with the next index.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; numLetter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="built_in">string</span> current, <span class="keyword">int</span> index, <span class="built_in">string</span> digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.size())&#123;</span><br><span class="line">            ans.push_back(current);</span><br><span class="line">            <span class="keyword">return</span>;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; numLetter[digits[index]].size(); i++)&#123;</span><br><span class="line">                current += numLetter[digits[index]][i];</span><br><span class="line">                recursion(current, index+<span class="number">1</span>, digits);</span><br><span class="line">                current.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">string</span> current = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        numLetter[<span class="string">&#x27;2&#x27;</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;3&#x27;</span>] = &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;4&#x27;</span>] = &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;5&#x27;</span>] = &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;6&#x27;</span>] = &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;7&#x27;</span>] = &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;8&#x27;</span>] = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;;</span><br><span class="line">        numLetter[<span class="string">&#x27;9&#x27;</span>] = &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;;</span><br><span class="line">        recursion(current, <span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Backtracking/" rel="tag">Backtracking</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hash-Table/" rel="tag">Hash Table</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1113"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/13/Leetcode1113/"
    >Leetcode Study Day 47</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/13/Leetcode1113/" class="article-date">
  <time datetime="2023-11-13T19:48:49.000Z" itemprop="datePublished">2023-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Implement-Trie-Prefix-Tree"><a href="#Implement-Trie-Prefix-Tree" class="headerlink" title="Implement Trie (Prefix Tree)"></a>Implement Trie (Prefix Tree)</h1><p>A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>
<p>Implement the Trie class:</p>
<p>Trie() Initializes the trie object.<br>void insert(String word) Inserts the string word into the trie.<br>boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.<br>boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // return True</span><br><span class="line">trie.search(&quot;app&quot;);     // return False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // return True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // return True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= word.length, prefix.length &lt;= 2000</span><br><span class="line">word and prefix consist only of lowercase English letters.</span><br><span class="line">At most 3 * 104 calls in total will be made to insert, search, and startsWith.</span><br></pre></td></tr></table></figure>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>My solution is easy to understand but cost a lot of time to process.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">         wordSet.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prefix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(string word: wordSet)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prefix[i] != word[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(prefix[i] == word[i] &amp;&amp; i == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_set &lt;string&gt; wordSet;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="Prefix-Tree"><a href="#Prefix-Tree" class="headerlink" title="Prefix Tree"></a>Prefix Tree</h2><p>I got the idea of using prefix tree from this <a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3307049/day-76-easiest-beginner-friendly-sol/?envType=study-plan-v2&envId=top-interview-150">post</a> in Leetcode.</p>
<p>I am going to explain his code with comment:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// create an array with 26 TrieNode pointers</span></span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isWordCompleted;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="built_in">sizeof</span>(children));</span><br><span class="line">        isWordCompleted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* newRoot = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            <span class="comment">// get the index of the alphabet</span></span><br><span class="line">            <span class="type">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// if the pointer is NULL, create a new TrieNode</span></span><br><span class="line">            <span class="keyword">if</span> (newRoot -&gt; children[alphabetIndex] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                newRoot -&gt; children[alphabetIndex] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// move the pointer to the next TrieNode</span></span><br><span class="line">            newRoot = newRoot -&gt; children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mark the word as completed</span></span><br><span class="line">        newRoot -&gt; isWordCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* newRoot = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            <span class="type">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// if the pointer is NULL, means the character is not in the tree</span></span><br><span class="line">            <span class="keyword">if</span> (newRoot -&gt; children[alphabetIndex] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            newRoot = newRoot -&gt; children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if the word is completed, return true</span></span><br><span class="line">        <span class="keyword">if</span> (newRoot -&gt; isWordCompleted == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* newRoot = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            <span class="type">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (newRoot -&gt; children[alphabetIndex] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            newRoot = newRoot -&gt; children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="Design-Add-and-Search-Words-Data-Structure"><a href="#Design-Add-and-Search-Words-Data-Structure" class="headerlink" title="Design Add and Search Words Data Structure"></a>Design Add and Search Words Data Structure</h1><p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>
<p>Implement the WordDictionary class:</p>
<p>WordDictionary() Initializes the object.<br>void addWord(word) Adds word to the data structure, it can be matched later.<br>bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots ‘.’ where dots can be matched with any letter.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input</span><br><span class="line">[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span><br><span class="line">[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,false,true,true,true]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">WordDictionary wordDictionary = new WordDictionary();</span><br><span class="line">wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">wordDictionary.search(&quot;pad&quot;); // return False</span><br><span class="line">wordDictionary.search(&quot;bad&quot;); // return True</span><br><span class="line">wordDictionary.search(&quot;.ad&quot;); // return True</span><br><span class="line">wordDictionary.search(&quot;b..&quot;); // return True</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= word.length &lt;= 25</span><br><span class="line">word in addWord consists of lowercase English letters.</span><br><span class="line">word in search consist of &#x27;.&#x27; or lowercase English letters.</span><br><span class="line">There will be at most 2 dots in word for search queries.</span><br><span class="line">At most 104 calls will be made to addWord and search.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Based on the idea of previous problem, we can use prefix tree to solve this problem. The only difference is that we need to consider the ‘.’ in the word. We can use recursive method to search the word in the tree. If we meet ‘.’, we need to search all the children of the current node. If the node we find is not correct, we need to move to the next node. If we run out of all 26 alphabet, we return false.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    TrieNode* children[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isCompleted;</span><br><span class="line">    <span class="built_in">TrieNode</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="built_in">sizeof</span>(children));</span><br><span class="line">        isCompleted = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode *root ;</span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode * newroot = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> character: word)&#123;</span><br><span class="line">            <span class="type">int</span> alphabetIndex = character - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(newroot-&gt;children[alphabetIndex] == <span class="literal">NULL</span>)</span><br><span class="line">                newroot-&gt;children[alphabetIndex] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            newroot = newroot-&gt;children[alphabetIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        newroot -&gt; isCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchRecursive</span>(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchRecursive</span><span class="params">(<span class="type">const</span> string &amp; word, <span class="type">int</span> index, TrieNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;isCompleted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> ch = word[index];</span><br><span class="line">        <span class="keyword">if</span>(ch != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> alphabetIndex = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;children[alphabetIndex] == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchRecursive</span>(word, index + <span class="number">1</span>, node-&gt;children[alphabetIndex]);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;children[i] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">searchRecursive</span>(word, index + <span class="number">1</span>, node-&gt;children[i]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Design/" rel="tag">Design</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hash-Table/" rel="tag">Hash Table</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Trie/" rel="tag">Trie</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1112"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/12/Leetcode1112/"
    >Leetcode Study Day 46</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/12/Leetcode1112/" class="article-date">
  <time datetime="2023-11-12T10:38:51.000Z" itemprop="datePublished">2023-11-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Minimum-Genetic-Mutation"><a href="#Minimum-Genetic-Mutation" class="headerlink" title="Minimum Genetic Mutation"></a>Minimum Genetic Mutation</h1><p>A gene string can be represented by an 8-character long string, with choices from ‘A’, ‘C’, ‘G’, and ‘T’.</p>
<p>Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.</p>
<p>For example, “AACCGGTT” –&gt; “AACCGGTA” is one mutation.<br>There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.</p>
<p>Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.</p>
<p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: startGene &#x3D; &quot;AACCGGTT&quot;, endGene &#x3D; &quot;AACCGGTA&quot;, bank &#x3D; [&quot;AACCGGTA&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: startGene &#x3D; &quot;AACCGGTT&quot;, endGene &#x3D; &quot;AAACGGTA&quot;, bank &#x3D; [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]</span><br><span class="line">Output: 2</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">0 &lt;&#x3D; bank.length &lt;&#x3D; 10</span><br><span class="line">startGene.length &#x3D;&#x3D; endGene.length &#x3D;&#x3D; bank[i].length &#x3D;&#x3D; 8</span><br><span class="line">startGene, endGene, and bank[i] consist of only the characters [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;].</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I asked ChatGPT for get some hints and pseudo codes, in general, his idea is to use BFS to find the shortest path. He stored the bank gene into a set. Then use BFS to store and pop the mutated gene.</p>
<p>Here is his pseudo code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">This problem can be approached as a graph traversal problem, where each gene string represents a node and a mutation is an edge between two nodes. The goal is to find the shortest path from the startGene to the endGene. Here&#39;s a step-by-step approach using Breadth-First Search (BFS), which is well-suited for finding the shortest path in unweighted graphs:</span><br><span class="line"></span><br><span class="line">Initialize: Create a queue for BFS and a set to keep track of visited nodes. Add the startGene to the queue.</span><br><span class="line"></span><br><span class="line">BFS Loop:</span><br><span class="line"></span><br><span class="line">While the queue is not empty, remove the first gene from the queue.</span><br><span class="line">Check if this gene is the endGene. If yes, return the number of mutations (depth) required to reach this gene.</span><br><span class="line">Otherwise, iterate over each character in the gene. For each character, try changing it to the other three possible nucleotides (&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;).</span><br><span class="line">For each modified gene, check if it is in the bank and not yet visited.</span><br><span class="line">If so, add it to the queue and mark it as visited.</span><br><span class="line">Return -1: If the queue gets empty and the endGene is not found, return -1, indicating no possible mutation path.</span><br></pre></td></tr></table></figure>
<p>Here’s a pseudo-code to illustrate this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pseudo</span><br><span class="line">function minGeneticMutation(startGene, endGene, bank):</span><br><span class="line">    if endGene not in bank:</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">    bankSet &#x3D; set(bank)</span><br><span class="line">    visited &#x3D; set()</span><br><span class="line">    queue &#x3D; [(startGene, 0)]  # (current gene, mutation steps)</span><br><span class="line"></span><br><span class="line">    while queue is not empty:</span><br><span class="line">        currentGene, steps &#x3D; queue.pop(0)</span><br><span class="line">        </span><br><span class="line">        if currentGene &#x3D;&#x3D; endGene:</span><br><span class="line">            return steps</span><br><span class="line"></span><br><span class="line">        for i in 0 to length(currentGene) - 1:</span><br><span class="line">            for nucleotide in [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]:</span><br><span class="line">                if nucleotide !&#x3D; currentGene[i]:</span><br><span class="line">                    mutatedGene &#x3D; currentGene[:i] + nucleotide + currentGene[i+1:]</span><br><span class="line">                    if mutatedGene in bankSet and mutatedGene not in visited:</span><br><span class="line">                        queue.append((mutatedGene, steps + 1))</span><br><span class="line">                        visited.add(mutatedGene)</span><br><span class="line"></span><br><span class="line">    return -1</span><br></pre></td></tr></table></figure>
<h3 id="Full-code"><a href="#Full-code" class="headerlink" title="Full code"></a>Full code</h3><p>Here is my code based on the pseudo code above, one thing I learnt is that we can use <code>substr</code> to split the string:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMutation</span><span class="params">(<span class="built_in">string</span> startGene, <span class="built_in">string</span> endGene, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">char</span>&gt; geneChar = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(find(bank.begin(), bank.end(), endGene) == bank.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; bankSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bank.size(); i++)</span><br><span class="line">            bankSet.insert(bank[i]);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; bankQ;</span><br><span class="line">        bankQ.push(&#123;startGene,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!bankQ.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> current = bankQ.front().first;</span><br><span class="line">            <span class="keyword">int</span> step = bankQ.front().second;</span><br><span class="line">            bankQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (current == endGene)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; current.size(); i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> singleGene: geneChar)&#123;</span><br><span class="line">                    <span class="built_in">string</span> mutatedGene = current.substr(<span class="number">0</span>, i) + singleGene + current.substr(i + <span class="number">1</span>, current.size());</span><br><span class="line">                    <span class="keyword">if</span> (bankSet.find(mutatedGene)!= bankSet.end() &amp;&amp; visited.find(mutatedGene) == visited.end())&#123;</span><br><span class="line">                        bankQ.push(&#123;mutatedGene, step+<span class="number">1</span>&#125;);</span><br><span class="line">                        visited.insert(mutatedGene);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h1><p>A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk such that:</p>
<p>Every adjacent pair of words differs by a single letter.<br>Every si for 1 &lt;= i &lt;= k is in wordList. Note that beginWord does not need to be in wordList.<br>sk == endWord<br>Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: beginWord &#x3D; &quot;hit&quot;, endWord &#x3D; &quot;cog&quot;, wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;&#x3D; beginWord.length &lt;&#x3D; 10</span><br><span class="line">endWord.length &#x3D;&#x3D; beginWord.length</span><br><span class="line">1 &lt;&#x3D; wordList.length &lt;&#x3D; 5000</span><br><span class="line">wordList[i].length &#x3D;&#x3D; beginWord.length</span><br><span class="line">beginWord, endWord, and wordList[i] consist of lowercase English letters.</span><br><span class="line">beginWord !&#x3D; endWord</span><br><span class="line">All the words in wordList are unique.</span><br></pre></td></tr></table></figure>
<h2 id="My-solution"><a href="#My-solution" class="headerlink" title="My solution"></a>My solution</h2><p>The main idea is similar to the previous one, which is to use BFS to find the shortest path. The only difference is that this time we need to find the words with only one word difference between the original one, whereas the previous one is to try to replace each character with the four characters.</p>
<p>Here is my code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">difference</span><span class="params">(<span class="built_in">string</span> current, <span class="built_in">string</span> word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; current.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (current[i] != word[i])</span><br><span class="line">                diff ++;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(find(wordList.begin(), wordList.end(), endWord) == wordList.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)</span><br><span class="line">            wordSet.insert(wordList[i]);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; wordQ;</span><br><span class="line">        wordQ.push(&#123;beginWord,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!wordQ.empty())&#123;</span><br><span class="line">            <span class="built_in">string</span> current = wordQ.front().first;</span><br><span class="line">            <span class="keyword">int</span> step = wordQ.front().second;</span><br><span class="line">            wordQ.pop();</span><br><span class="line">            <span class="keyword">if</span> (current == endWord)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">string</span> word: wordSet)&#123;</span><br><span class="line">                <span class="keyword">if</span> (difference(current, word) == <span class="number">1</span> &amp;&amp; visited.find(word) == visited.end())&#123;</span><br><span class="line">                    wordQ.push(&#123;word,step+<span class="number">1</span>&#125;);</span><br><span class="line">                    visited.insert(word);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hash-Table/" rel="tag">Hash Table</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/" rel="tag">String</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Leetcode1111-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/11/Leetcode1111-2/"
    >Leetcode Study Day 45</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/11/Leetcode1111-2/" class="article-date">
  <time datetime="2023-11-11T14:04:57.000Z" itemprop="datePublished">2023-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode/">Leetcode</a>
  </div>
 
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Snakes-and-Ladders"><a href="#Snakes-and-Ladders" class="headerlink" title="Snakes and Ladders"></a>Snakes and Ladders</h1><p>You are given an n x n integer matrix board where the cells are labeled from 1 to n2 in a Boustrophedon style starting from the bottom left of the board (i.e. board[n - 1][0]) and alternating direction each row.</p>
<p>You start on square 1 of the board. In each move, starting from square curr, do the following:</p>
<p>Choose a destination square next with a label in the range [curr + 1, min(curr + 6, n2)].<br>This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.<br>If next has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to next.<br>The game ends when you reach the square n2.<br>A board square on row r and column c has a snake or ladder if board[r][c] != -1. The destination of that snake or ladder is board[r][c]. Squares 1 and n2 do not have a snake or ladder.</p>
<p>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.</p>
<p>For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.<br>Return the least number of moves required to reach the square n2. If it is not possible to reach the square, return -1.</p>
<p><img src="image.png" alt="Alt text"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">In the beginning, you start at square 1 (at row 5, column 0).</span><br><span class="line">You decide to move to square 2 and must take the ladder to square 15.</span><br><span class="line">You then decide to move to square 17 and must take the snake to square 13.</span><br><span class="line">You then decide to move to square 14 and must take the ladder to square 35.</span><br><span class="line">You then decide to move to square 36, ending the game.</span><br><span class="line">This is the lowest possible number of moves to reach the last square, so return 4.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: board &#x3D; [[-1,-1],[-1,3]]</span><br><span class="line">Output: 1</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; board.length &#x3D;&#x3D; board[i].length</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 20</span><br><span class="line">board[i][j] is either -1 or in the range [1, n2].</span><br><span class="line">The squares labeled 1 and n2 do not have any ladders or snakes.</span><br></pre></td></tr></table></figure>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>I found this <a target="_blank" rel="noopener" href="https://leetcode.com/problems/snakes-and-ladders/solutions/3092265/c-simple-bfs-with-full-explanation-beats-100/?envType=study-plan-v2&envId=top-interview-150">solution</a> from Leetcode. Here is his explanation:</p>
<blockquote>
<p>Intuition</p>
</blockquote>
<blockquote>
<p>The intuition behind this code is that it uses a breadth-first search (BFS) algorithm to find the minimum number of moves required to reach the last cell of the board from the first cell. BFS is an algorithm that explores all the vertices of a graph or all the nodes of a tree level by level.</p>
</blockquote>
<blockquote>
<p>Approach</p>
</blockquote>
<blockquote>
<p>The method starts by creating a vector of pairs called “cells” that stores the row and column of each cell in the board. It also creates a vector of integers called “dist” that stores the minimum number of moves required to reach each cell and initializes it to -1.</p>
</blockquote>
<blockquote>
<p>It then uses a queue to keep track of the cells to be visited and starts by pushing the first cell (cell 1) into the queue. The method then enters a while loop that continues until the queue is empty. In each iteration of the loop, it takes the front element of the queue, which is the current cell, and pops it from the queue.</p>
</blockquote>
<blockquote>
<p>For the current cell, the method loops through all the possible next cells which are from curr+1 to min(curr+6,n*n) (because in each move we can move to a dice roll max 6 steps) and checks if the minimum number of moves required to reach that cell has not been assigned yet. If it has not been assigned yet, the method assigns the minimum number of moves required to reach that cell as the minimum number of moves required to reach the current cell plus one. It also pushes the next cell into the queue to be visited in the next iteration.</p>
</blockquote>
<blockquote>
<p>The method then continues this process until all the cells have been visited, and the minimum number of moves required to reach each cell has been assigned. Finally, the method returns the minimum number of moves required to reach the last cell, which is stored in dist[n*n].</p>
</blockquote>
<blockquote>
<p>It also handles the case if there is a snake or ladder at the cell, it directly assigns the destination cell number as the cell number.</p>
</blockquote>
<blockquote>
<p>Complexity</p>
</blockquote>
<blockquote>
<p>Time complexity:</p>
</blockquote>
<blockquote>
<p>The time complexity of this code is O(n^2), where n is the size of the board. This is because the method uses a breadth-first search algorithm to traverse through each cell of the board and assigns the distance of each cell from the starting cell. The outer loop iterates n times, and the inner loop iterates n times, so the total number of iterations is n*n.</p>
</blockquote>
<blockquote>
<p>Note that this is assuming the queue and vector operations have a constant time complexity, which is typical but not guaranteed.</p>
</blockquote>
<blockquote>
<p>Space complexity:</p>
</blockquote>
<blockquote>
<p>The space complexity of this code is also O(n^2). This is because the method uses a vector of integers called “dist” to keep track of the minimum number of moves required to reach each cell, and this vector has nn elements. The method also uses a vector of pairs called “cells” to keep track of the row and column of each cell, and this vector also has nn elements. The method also uses a queue to keep track of the cells to be visited, which can have at most n*n elements.</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.size(), lbl = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cells(n*n+<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">columns</span><span class="params">(n)</span></span>;</span><br><span class="line">        iota(columns.begin(), columns.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = n - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column : columns) &#123;</span><br><span class="line">                cells[lbl++] = &#123;row, column&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(columns.begin(), columns.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n*n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next = curr + <span class="number">1</span>; next &lt;= min(curr+<span class="number">6</span>, n*n); next++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [row, column] = cells[next];</span><br><span class="line">                <span class="keyword">int</span> destination = board[row][column] != <span class="number">-1</span> ? board[row][column] : next;</span><br><span class="line">                <span class="keyword">if</span> (dist[destination] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    dist[destination] = dist[curr] + <span class="number">1</span>;</span><br><span class="line">                    q.push(destination);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n*n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Breadth-First-Search/" rel="tag">Breadth-First Search</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Matrix/" rel="tag">Matrix</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/">Next Page</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2024
        <i class="ri-heart-fill heart_icon"></i> Yangyang Cui
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Yangyang"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">categories</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>

</html>